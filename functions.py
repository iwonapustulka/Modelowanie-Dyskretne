'''    Author: Iwona Pustulka    Date: 13.10.2020    Last update: 24.11.2020    No_lab: 6'''from PIL import ImageTkfrom PIL import Image as imfrom tkinter import *import numpy as npimport copyfrom matplotlib import pyplot as pltimport random#GUIdef open_img1():    img = im.open("Mapa_MD_no_terrain_low_res_Gray.bmp")    img.save("img_change.bmp")    image = ImageTk.PhotoImage(img)    panel.itemconfig(image_id, image=image)    panel.image = image    img.close()#GUIdef open_img2():    img = im.open("Mapa_MD_no_terrain_low_res_dark_Gray.bmp")    img.save("img_change.bmp")    image = ImageTk.PhotoImage(img)    panel.itemconfig(image_id, image=image)    panel.image = image    img.close()#LAB_no1def changeimg():    img = im.open("img_change.bmp")    image = img.point(lambda x: x + var.get())    img.close()    image.save("img_change.bmp")    img_TK = ImageTk.PhotoImage(image)    panel.itemconfig(image_id, image=img_TK)    panel.image = img_TK    image.close()#LAB_no1def binarization():    img = im.open("img_change.bmp")    img_bin = img.point(lambda x: 0 if x <= int(value.get()) else 255)    img.close()    img_bin.save("img_change.bmp")    img_binTK = ImageTk.PhotoImage(img_bin)    panel.itemconfig(image_id, image=img_binTK)    panel.image = img_binTK    img_bin.close()    return img_bin#LAB_no2pom_low = np.array([[1 / 9, 1 / 9, 1 / 9], [1 / 9, 1 / 9, 1 / 9], [1 / 9, 1 / 9, 1 / 9]])pom_up = np.array([[-1, -1, -1], [-1, 9, -1], [-1, -1, -1]])gauss = np.array([[1/2, 4/32, 1/32], [4/32, 32/32, 4/32], [1/32, 4/32, 1/32]])#LAB_no2def help_function(image, x, y, zm): #funkcja pomocnicza do wyodrebniania 9 pikseli    w, h = image.size    tab = np.zeros((3, 3))    for i in range(-1, 2):        for j in range(-1, 2):            if -1 < x+i < w and -1 < y+j < h:                tab[i+1][j+1] = image.getpixel((x+i, y+j))            else:                if zm == 1:  #filter                    tab[i+1][j+1] = 0                elif zm == 2:  #dilatation-erosion                    tab[i+1][j+1] = -1    return tab#LAB_no2def filter(pom_low):    img = im.open("img_change.bmp")    w, h = img.size    image_pom = im.new('P', (w, h))    for i in range(w):        for j in range(h):            result = help_function(img, i, j, 1)            pom = pom_low*result            temp = pom.sum()            if temp > 255:                temp = 255            elif temp < 0:                temp = 0            image_pom.putpixel((i, j), int(temp))    img.close()    image_pom.save("img_change.bmp")    img_TK = ImageTk.PhotoImage(image_pom)    panel.itemconfig(image_id, image=img_TK)    panel.image = img_TK    image_pom.close()#LAB_no2def check(tab, zm):    for x in range(2):        for y in range(2):            if tab[x][y] == 255 and zm == 1:  #dilatation                return 255            elif tab[x][y] == 0 and zm == 2:  #erosion                return 0#LAB_no2def dilatation_erosion(zm):    img = im.open("img_change.bmp")    w, h = img.size    image_pom = im.new('P', (w, h))    for i in range(w):        for j in range(h):            result = help_function(img, i, j, 2)            if zm == 1:  #erosion                if check(result, 1) == 255:                    image_pom.putpixel((i, j), 255)                else:                    image_pom.putpixel((i, j), 0)            if zm == 2:  #dilatation                if check(result, 2) == 0:                    image_pom.putpixel((i, j), 0)                else:                    image_pom.putpixel((i, j), 255)    img.close()    image_pom.save("img_change.bmp")    img_TK = ImageTk.PhotoImage(image_pom)    panel.itemconfig(image_id, image=img_TK)    panel.image = img_TK    image_pom.close()#LAB_no2def morphological(zm):    if zm == 1: #open        dilatation_erosion(1)  #erosion        dilatation_erosion(2)  #dilatation    elif zm == 2:  #close        dilatation_erosion(2)  #dilatation        dilatation_erosion(1)  #erosion#LAB_no3def convert(value):    zm = []    for znak in bin(value)[2:]:        zm.append(int(znak)*255)    while len(zm) != 8:        zm.insert(0, int(0))    return zm#LAB_no3def cellular_machine(value, zm):    length = int(value_aut.get())    pom_list = np.zeros(length)    if zm == 1:        pom_list[0] = 255        pom_list[length-1] = 255    else:        pom_list[int(length/2)] = 255    zm = convert(value)    count = 1    tab_new = [pom_list]    tab1 = np.zeros(length)    while count < length:        for i in range(len(pom_list)):            if i == len(pom_list)-1:                if pom_list[i - 1] == 255 and pom_list[i] == 255 and pom_list[0] == 255:                    tab1[i] = zm[0]                elif pom_list[i - 1] == 255 and pom_list[i] == 255 and pom_list[0] == 0:                    tab1[i] = zm[1]                elif pom_list[i - 1] == 255 and pom_list[i] == 0 and pom_list[0] == 255:                    tab1[i] = zm[2]                elif pom_list[i - 1] == 255 and pom_list[i] == 0 and pom_list[0] == 0:                    tab1[i] = zm[3]                elif pom_list[i - 1] == 0 and pom_list[i] == 255 and pom_list[0] == 255:                    tab1[i] = zm[4]                elif pom_list[i - 1] == 0 and pom_list[i] == 255 and pom_list[0] == 0:                    tab1[i] = zm[5]                elif pom_list[i - 1] == 0 and pom_list[i] == 0 and pom_list[0] == 255:                    tab1[i] = zm[6]                elif pom_list[i - 1] == 0 and pom_list[i] == 0 and pom_list[0] == 0:                    tab1[i] = zm[7]            else:                if pom_list[i - 1] == 255 and pom_list[i] == 255 and pom_list[i + 1] == 255:                    tab1[i] = zm[0]                elif pom_list[i - 1] == 255 and pom_list[i] == 255 and pom_list[i + 1] == 0:                    tab1[i] = zm[1]                elif pom_list[i - 1] == 255 and pom_list[i] == 0 and pom_list[i + 1] == 255:                    tab1[i] = zm[2]                elif pom_list[i - 1] == 255 and pom_list[i] == 0 and pom_list[i + 1] == 0:                    tab1[i] = zm[3]                elif pom_list[i - 1] == 0 and pom_list[i] == 255 and pom_list[i + 1] == 255:                    tab1[i] = zm[4]                elif pom_list[i - 1] == 0 and pom_list[i] == 255 and pom_list[i + 1] == 0:                    tab1[i] = zm[5]                elif pom_list[i - 1] == 0 and pom_list[i] == 0 and pom_list[i + 1] == 255:                    tab1[i] = zm[6]                elif pom_list[i - 1] == 0 and pom_list[i] == 0 and pom_list[i + 1] == 0:                    tab1[i] = zm[7]        count = count + 1        c = copy.copy(tab1)        tab_new.append(c)        pom_list = c    tab_new = np.reshape(tab_new, (len(pom_list), count))    image_pom = im.fromarray(tab_new)    img_TK = ImageTk.PhotoImage(image_pom)    panel.itemconfig(image_id, image=img_TK)    panel.image = img_TK    image_pom.close()#LAB_no4class Board(object):    def __init__(self, size):        #glider no 1        self.glider = np.zeros(size)        self.glider[6, 36] = 1        self.glider[7, 37] = 1        self.glider[8, 37] = 1        self.glider[6, 38] = 1        self.glider[7, 38] = 1        #oscylator no 2        self.oscylator = np.zeros(size)        self.oscylator[100, 100] = 1        self.oscylator[100, 101] = 1        self.oscylator[100, 102] = 1        #niezmienne no 3        self.niezmienne = np.zeros(size)        self.niezmienne[50, 303] = 1        self.niezmienne[50, 304] = 1        self.niezmienne[51, 302] = 1        self.niezmienne[51, 305] = 1        self.niezmienne[52, 303] = 1        self.niezmienne[52, 304] = 1        #losowe no 4        self.losowe = np.random.randint(2, size=size)        #reczne no 5        self.reczne = np.zeros(size)        tab1 = value_reczx.get().split(",")        tab2 = value_reczy.get().split(",")        tab1_int = []        tab2_int = []        for j in range(len(tab1)):            tab1_int.append(int(tab1[j]))            tab2_int.append(int(tab2[j]))        for i in range(len(tab1_int)):            self.reczne[tab1_int[i], tab2_int[i]] = 1        self.actions = Actions(self)        self.zm = 0    def animation(self, option):        i = self.zm        plt.title("Game of life")        while True:            if option == 1:                if i == 0:                    img = plt.imshow(self.glider, plt.cm.gray)                else:                    img.set_data(self.glider)            if option == 2:                if i == 0:                    img = plt.imshow(self.oscylator, plt.cm.gray)                else:                    img.set_data(self.oscylator)            if option == 3:                if i == 0:                    img = plt.imshow(self.niezmienne, plt.cm.gray)                else:                    img.set_data(self.niezmienne)            if option == 4:                if i == 0:                    img = plt.imshow(self.losowe, plt.cm.gray)                else:                    img.set_data(self.losowe)            if option == 5:                if i == 0:                    img = plt.imshow(self.reczne, plt.cm.gray)                else:                    img.set_data(self.reczne)            i += 1            self.actions.new_life(option)            plt.pause(0.001)#LAB_no4class Actions(object):    def __init__(self, board):        self.glider = board.glider        self.oscylator = board.oscylator        self.niezmienne = board.niezmienne        self.losowe = board.losowe        self.reczne = board.reczne    def count_neigbors(self, option):        if option == 1:            state = self.glider        elif option == 2:            state = self.oscylator        elif option == 3:            state = self.niezmienne        elif option == 4:            state = self.losowe        elif option == 5:            state = self.reczne        n = (state[0:-2, 0:-2] + state[0:-2, 1:-1] + state[0:-2, 2:] + state[1:-1, 0:-2] + state[1:-1, 2:] + state[2:, 0: -2] + state[2:, 1:-1] + state[2:, 2:])        return n    def new_life(self, option):        n = self.count_neigbors(option)        if option == 1:            state = self.glider        elif option == 2:            state = self.oscylator        elif option == 3:            state = self.niezmienne        elif option == 4:            state = self.losowe        elif option == 5:            state = self.reczne        alive = ((n == 3) & (state[1:-1, 1:-1] == 0)) | (((n == 2) | (n == 3)) & (state[1:-1, 1:-1] == 1))        for i in range(len(state)):            state[i] = 0        state[1:-1, 1:-1][alive] = 1        return state#LAB_no4def game_of_life(option):    board_height = 330    board_width = 330    board = Board((board_height, board_width))    for i in board.animation(option):        pass#LAB_no5-6class Forest(object):    def __init__(self, size):        self.state = np.zeros(size)        self.type = np.zeros(size)        self.probability = np.zeros(size)        self.state[150, 250] = 1        self.state[60, 300] = 1        self.state[300, 50] = 1        self.actions = Actions(self)        self.zm = 0        self.list_probability = [0, 1]        img = self.actions.colorful_image()        for i in range(600):            for j in range(330):                self.probability [j, i] = random.choice(self.list_probability)                if img.getpixel((i, j)) == (0, 0, 255):                    self.type[j, i] = 1  # water    def animation(self, option):        zm = self.zm        plt.title("Forest fire")        first = self.actions.colorful_image()        type = self.type        while True:            if (option == 1) | (option == 2):                for i in range(600):                    for j in range(330):                        if type[j][i] == 1:                            continue                        else:                            if zm == 0:                                img = plt.imshow(first)                            else:                                img.set_data(first)                            zm += 1                            first = self.actions.new_life(i, j, option)                            plt.pause(0.00001)#LAB_no5-6class Actions(object):    def __init__(self, forest):        self.state = forest.state        self.type = forest.type        self.probability = forest.probability    def colorful_image(self):        img = im.open("Mapa_MD_no_terrain_low_res_dark_Gray.bmp")        img_bin = img.point(lambda x: 0 if x <= int(value.get()) else 255)        img_bin.save("binarization.bmp")        img.close()        img_bin.close()        image = im.open("binarization.bmp").convert("RGB")        w, h = image.size        image_pom = im.new('P', (w, h)).convert("RGB")        for i in range(w):            for j in range(h):                r, g, b = image.getpixel((i, j))                if r == 255 and g == 255 and b == 255:                    image_pom.putpixel((i, j), (0, 255, 0))                elif r == 0 and g == 0 and b == 0:                    image_pom.putpixel((i, j), (0, 0, 255))                if self.state[j][i] == 1:                    # print(r"loc: {0} {1}".format(i, j) + str(self.state[j][i]))                    image_pom.putpixel((i, j), (255, 255, 0))        return image_pom    def count_neigbors(self, option, i, j):        if (option == 1) | (option == 2):            state = self.state            n = (state[0:-2, 0:-2] + state[0:-2, 1:-1] + state[0:-2, 2:] + state[1:-1, 0:-2] + state[1:-1, 2:] + state[2:,0: -2] + state[ 2:,1:-1] + state[2:, 2:])        return n    def change_color(self, option):        if (option == 1) | (option == 2):            state = self.state            first = copy.copy(self.colorful_image())            for i in range(600):                for j in range(330):                    if state[j][i] == 1:                        first.putpixel((i, j), (255, 255, 0))  # yellow                    elif state[j][i] == 2:                        first.putpixel((i, j), (255, 0, 0))  # red                    elif state[j][i] == 3:                        first.putpixel((i, j), (0, 0, 0))  # black        return first    def new_life(self, i, j, option):        if option == 1:            n = self.count_neigbors(option, i, j)            first = copy.copy(self.colorful_image())            #print(n)            state = self.state            type = self.type            burning = ((n > 0) & (state[1:-1, 1:-1] == 0) & (type[1:-1, 1:-1] == 0))            burned = ((state[1:-1, 1:-1] == 1) & (type[1:-1, 1:-1] == 0))            end = ((state[1:-1, 1:-1] == 2) & (type[1:-1, 1:-1] == 0))            state[1:-1, 1:-1][burning] = 1            state[1:-1, 1:-1][burned] = 2            state[1:-1, 1:-1][end] = 3            if img.getpixel((i, j)) == (0, 0, 255):                pass            else:                first = self.change_color(option)        elif option == 2:            probability = self.probability            n = self.count_neigbors(option, i, j)            first = copy.copy(self.colorful_image())            state = self.state            type = self.type            burning = ((n > 0) & (state[1:-1, 1:-1] == 0) & (type[1:-1, 1:-1] == 0) & (probability[1:-1, 1:-1] == 1))            burned = ((state[1:-1, 1:-1] == 1) & (type[1:-1, 1:-1] == 0) & (probability[1:-1, 1:-1] == 1))            end = ((state[1:-1, 1:-1] == 2) & (type[1:-1, 1:-1] == 0) & (probability[1:-1, 1:-1] == 1))            state[1:-1, 1:-1][burning] = 1            state[1:-1, 1:-1][burned] = 2            state[1:-1, 1:-1][end] = 3            if img.getpixel((i, j)) == (0, 0, 255):                pass            else:                first = self.change_color(option)        return first#LAB_no5-6def forest_fire(option):    forest_height = 330    forest_width = 600    forest = Forest((forest_height, forest_width))    for z in forest.animation(option):        pass#OKIENKOwindow = Tk()window.title("Discrete Modeling- App")window.resizable(width=False, height=False)  # zakaz zmieniania rozmiarow oknatop_frame = Frame(window)down_frame = Frame(window)right_frame = Frame(window)left_frame = Frame(window)top_right_frame = Frame(right_frame)down_right_frame = Frame(right_frame)down_down_frame = Frame(down_right_frame)button_img1 = Button(top_frame, text="Image 1", command=open_img1).pack(side=LEFT)button_img2 = Button(top_frame, text='Image 2', command=open_img2).pack(side=LEFT)button = Button(top_right_frame, text="Change image", command=changeimg).pack(side=TOP)label_light = Label(top_right_frame, text="LIGHTEN").pack(side=RIGHT)label_dark = Label(top_right_frame, text="DARKEN").pack(side=LEFT)var = DoubleVar()  # wartosc suwakaslider = Scale(top_right_frame, orient=HORIZONTAL, variable=var, from_=-250, to=250)slider.pack(side=TOP)button_bin = Button(top_right_frame, text="Binary image", command=binarization).pack(side=LEFT)value = Entry(top_right_frame)value.insert(0, "170") #wartosc poczatkowa jesli nic nie wpiszemyvalue.pack(side=RIGHT)panel = Canvas(left_frame, width=600, height=330)panel.pack(side=LEFT)img = im.open("Mapa_MD_no_terrain_low_res_Gray.bmp")img.save("img_change.bmp")image = ImageTk.PhotoImage(img)image_id = panel.create_image(0, 0, anchor=NW, image=image)button_low = Button(down_right_frame, text="LOW_PASS_FILTER", command=lambda: filter(pom_low)).pack(side=BOTTOM)button_up = Button(down_right_frame, text="UP_PASS_FILTER", command=lambda: filter(pom_up)).pack(side=BOTTOM)button_gauss = Button(down_right_frame, text="GAUSS FILTER", command=lambda: filter(gauss)).pack(side=BOTTOM)button_dilatation = Button(down_right_frame, text="DILATATION", command=lambda: dilatation_erosion(1)).pack(side=LEFT)button_erosion = Button(down_right_frame, text="EROSION", command=lambda: dilatation_erosion(2)).pack(side=LEFT)button_open = Button(down_right_frame, text="OPENING", command=lambda: morphological(1)).pack(side=RIGHT)button_close = Button(down_right_frame, text="CLOSING", command=lambda: morphological(2)).pack(side=LEFT)button_life_gl = Button(down_frame, text="GAME OF LIFE-glider", command=lambda: game_of_life(1)).pack(side=TOP)button_life_osc = Button(down_frame, text="GAME OF LIFE-oscylator", command=lambda: game_of_life(2)).pack(side=TOP)button_life_nzm = Button(down_frame, text="GAME OF LIFE-niezmienne", command=lambda: game_of_life(3)).pack(side=TOP)button_life_los = Button(down_frame, text="GAME OF LIFE-losowe", command=lambda: game_of_life(4)).pack(side=TOP)button_life_recz = Button(down_frame, text="GAME OF LIFE-reczne", command=lambda: game_of_life(5)).pack(side=TOP)value_reczx = Entry(down_frame)value_reczx.insert(0, "99,100, 101, 101,102,103") #wartosc poczatkowa jesli nic nie wpiszemyvalue_reczx.pack(side=TOP)value_reczy = Entry(down_frame)value_reczy.insert(0, "100, 100,100,101, 101,101") #wartosc poczatkowa jesli nic nie wpiszemyvalue_reczy.pack(side=TOP)button_fire_normal = Button(down_frame, text="Forest fire-normal", command=lambda: forest_fire(1)).pack(side=TOP)button_fire_probability = Button(down_frame, text="Forest fire-probability", command=lambda: forest_fire(2)).pack(side=TOP)value_aut = Entry(down_frame)value_aut.insert(0, "300") #wartosc poczatkowa jesli nic nie wpiszemyvalue_aut.pack(side=RIGHT)value_edges = Entry(down_frame)value_edges.insert(0, "0") #wartosc poczatkowa jesli nic nie wpiszemyvalue_edges.pack(side=RIGHT)value_no = Entry(down_frame)value_no.insert(0, "90") #wartosc poczatkowa jesli nic nie wpiszemyvalue_no.pack(side=RIGHT)button_30 = Button(down_frame, text="AUTOMAT 1D", command=lambda: cellular_machine(int(value_no.get()), int(value_edges.get()))).pack(side=LEFT)top_frame.pack(side=TOP)down_frame.pack(side=BOTTOM)right_frame.pack(side=RIGHT)left_frame.pack(side=LEFT)top_right_frame.pack(side=TOP)down_right_frame.pack(side=BOTTOM)down_down_frame.pack(side=BOTTOM)window.mainloop()